/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package Exchange.Matching.server;
import Exchange.Matching.server.*;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.parsers.*;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class Server {
    private ServerSocket socket;
    private Checker checker;
    private static int task_id;
    private static db stockDB;

    public Server() throws IOException, SQLException{
        socket=new ServerSocket(12345);
        task_id=0;
        stockDB = new db();
    }

    public void listen() throws Exception{
        Socket socket=this.socket.accept();
        task_id++;
        new Thread(new Task(socket,task_id)).start();
    }

    class Task implements Runnable{
        private Socket socket;
        private DataInputStream Trans;
        private FileOutputStream fileout;
        private int task_id;
        public Task(Socket socket,int task_id){
            this.socket=socket;
            this.task_id=task_id;

        }
        
        @Override
        public void run(){
            try{
                // InputStreamReader reader=new InputStreamReader(socket.getInputStream());
                // System.out.println((char)reader.read());
                Trans=new DataInputStream(socket.getInputStream());
                long fileLen=Trans.readLong();
                System.out.println(fileLen);

                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
                DocumentBuilder builder = factory.newDocumentBuilder();
                Document doc=builder.parse(Trans);
                Map<String,Object> to_check=new HashMap<>();
                switch (doc.getFirstChild().getNodeName()){
                    case "create" :
                        to_check=create_parse(doc.getFirstChild());
                    case "transactions":
                        to_check=transactions_parse(doc.getFirstChild());
                }
                for (Object o:to_check.values()){
                    checker.visit(o);
                }


            }catch(Exception e){
                e.printStackTrace();
            }finally{
                try{

                    socket.close();
                }catch(Exception e){}
            }
        }
    }

    public Map<String,Object> create_parse(Node n) {
        Map<String,Object> parseObjects=new HashMap<String,Object>();
        for (Node child = n.getFirstChild(); child != null; child = child.getNextSibling()) {
            switch (child.getNodeName()){
            case "account":
                int id=-1;
                int balance=-1;
                NamedNodeMap account_attrs= child.getAttributes();
                for(int j=0;j<account_attrs.getLength();j++){
                    Node x=account_attrs.item(j);
                    switch (x.getNodeName()){
                        case "id":
                            id=Integer.parseInt(x.getNodeValue());
                        case "balance":
                            balance=Integer.parseInt(x.getNodeValue());
                    }
                } 
                
                Account account=new Account(id,balance);
                parseObjects.put("create",account);
                break;
            case "symbol":
                NamedNodeMap sym_attrs= child.getAttributes();
                String symbol_name=sym_attrs.item(0).getNodeValue();
                for (Node sym_child = child.getFirstChild(); sym_child != null; sym_child = sym_child.getNextSibling()){
                    if (sym_child.getNodeName()=="account"){
                        NamedNodeMap sym_account=sym_child.getAttributes();
                        int sym_amount=Integer.parseInt(sym_child.getTextContent());
                        System.out.println(sym_child.getTextContent());
                        for(int j=0;j<sym_account.getLength();j++){
                            Node x=sym_account.item(j);
                            int sym_accountid=Integer.parseInt(x.getNodeValue());
                            System.out.println(x.getNodeName()+" "+x.getNodeValue());
                            Position position=new Position(symbol_name, sym_amount, sym_accountid);
                            parseObjects.put("Sym",position);
                        }
                    }
                }
                break;

            }
        }
        return parseObjects;
    }

    public Map<String,Object> transactions_parse(Node n) {
        Map<String,Object> parseObjects=new HashMap<String,Object>();
        int account_id=Integer.parseInt(n.getAttributes().item(0).getNodeValue());
        System.out.println(account_id);
        for (Node child = n.getFirstChild(); child != null; child = child.getNextSibling()) {
            switch (child.getNodeName()){
            case "order":
                NamedNodeMap account_attrs= child.getAttributes();
                String symbol="error";
                int amount=0;
                Double limit=0.0;
                for(int j=0;j<account_attrs.getLength();j++){
                    Node x=account_attrs.item(j);
                    switch (x.getNodeName()){
                        case "sym":
                            symbol=x.getNodeValue();
                            System.out.println(symbol);
                            break;
                        case "amount":
                            amount=Integer.parseInt(x.getNodeValue());
                            System.out.println(amount);
                            break;
                        case "limit":
                            limit=Double.parseDouble(x.getNodeValue());
                            System.out.println(limit);
                            break;
                    }
                }                               
                Order order=new Order(account_id,symbol,amount,limit);
                parseObjects.put("order",order);
                break;
            case "query":
                int query_transaction_id=Integer.parseInt(child.getAttributes().item(0).getNodeValue());
                System.out.println(query_transaction_id);
                parseObjects.put("query",query_transaction_id);
                break;
            case "cancel":
                int cancel_transaction_id=Integer.parseInt(child.getAttributes().item(0).getNodeValue());
                System.out.println(cancel_transaction_id);
                parseObjects.put("cancel",cancel_transaction_id);
                break;
            }
        }
        return parseObjects;
    }

    public void checkRule(){}
    
    public static void main(String[] args) throws SQLException {
        try{
            Server server=new Server();
            server.listen();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
